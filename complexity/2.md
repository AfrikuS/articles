* контроллеры
  * тонкие контроллеры
  * пректирование по rest
  * иерархия контроллеров
  * responders
  * аутентификация
  * breadcrumbs
  
# Управление сложностью в проектах на ruby on rails. Часть 2.

В предыдущей статье я рассказал про представления. Теперь поговорим про контроллеры.

Контроллер обеспечивает связь между пользователем и системой. 
Контроллер:
* получает информацию от пользователя, 
* выполняет необходимые действия, 
* отправляет результат пользователю.

Контроллер содержит только логику взаимодействия с пользователем, например:
* роутинг,
* отображение ошибок
* сессии пользователей
* редиректы
* хлебные крошки

Бизнес логика должна храниться отдельно. 
Например, ваше приложение должно взаимодействовать с пользователем через командную строку с помощью rake команд.
Rake команды по сути те же контроллеры и логика должна разделяться между ними. Так же это хорошо для тестирования. Протестировать специфическое поведение бизнес логики легче отдельно.

# REST

Я не буду углубляться в теорию REST, а расскажу веши, имеющие отношение к rails.

Возьмем для примера работу с сессиями. Пользователь может: 
* открыть форму входа
* отправить данные формы и войти в систему
* выйти из системы
* администатор может стать другим пользователем

Для реализации этого функционала создаем одиночный ресурс session, соответственно, со следующими экшенами: new, create, destroy, update.

Таким образом у нас есть один контроллер, который отвечает только за сессии.

Рассмотрим пример сложнее. Есть сущность проект и контролеер, реализующий crud операции. 
Проект может быть активным или завершенным. При завершении проекта нужно указать дату фактического завершения и причину задержки. Соответственно нам нужно 2 экшена: для отображения формы и обработки данных из формы. Первое очевидное и неверное решение - добавить 2 новых метода в ProjectsController. Правильное решение - создать вложенный ресурс "завершене проекта". 

```
resources :projects do
  scope module: :projects do
    resource :finish
    # GET /projects/1/finish/new
    # POST /projects/1/finish
  end
end
```

В этом контроллере мы добавим проверку статуса: а можем ли мы вообще завершать проект?

```
class Web::Projects::FinishesController < Web::Projects::ApplicationController
  before_action :check_availability

  def new
  end

  def create
  end

  private
  def check_availability
    redirect_to resource_project unless resource_project.can_finish?
  end
end
```

Аналогично можно поступать с пошаговыми формами: каждый шаг - это отдельный вложенный ресурс.

Идеальный случай, это когда используется только стандартные экшены. Понятно, что бывают исключения, но это случается очень редко.



