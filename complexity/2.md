* контроллеры
  * тонкие контроллеры
  * пректирование по rest
  * responders
  * иерархия контроллеров
  * breadcrumbs
  
# Управление сложностью в проектах на ruby on rails. Часть 2.

В предыдущей статье я рассказал про представления. Теперь поговорим про контроллеры.

Контроллер обеспечивает связь между пользователем и системой. 
Контроллер:
* получает информацию от пользователя, 
* выполняет необходимые действия, 
* отправляет результат пользователю.

Контроллер содержит только логику взаимодействия с пользователем, например:
* роутинг,
* отображение ошибок
* сессии пользователей
* редиректы
* хлебные крошки

Бизнес логика должна храниться отдельно. 
Например, ваше приложение должно взаимодействовать с пользователем через командную строку с помощью rake команд.
Rake команды по сути те же контроллеры и логика должна разделяться между ними. Так же это хорошо для тестирования. Протестировать специфическое поведение бизнес логики легче отдельно.

## REST

Я не буду углубляться в теорию REST, а расскажу веши, имеющие отношение к rails.

Возьмем для примера работу с сессиями. Пользователь может: 
* открыть форму входа
* отправить данные формы и войти в систему
* выйти из системы
* администатор может стать другим пользователем

Для реализации этого функционала создаем одиночный ресурс session, соответственно, со следующими экшенами: new, create, destroy, update.

Таким образом у нас есть один контроллер, который отвечает только за сессии.

Рассмотрим пример сложнее. Есть сущность проект и контролеер, реализующий crud операции. 
Проект может быть активным или завершенным. При завершении проекта нужно указать дату фактического завершения и причину задержки. Соответственно нам нужно 2 экшена: для отображения формы и обработки данных из формы. Первое очевидное и неверное решение - добавить 2 новых метода в ProjectsController. Правильное решение - создать вложенный ресурс "завершене проекта". 

```
resources :projects do
  scope module: :projects do
    resource :finish
    # GET /projects/1/finish/new
    # POST /projects/1/finish
  end
end
```

В этом контроллере мы добавим проверку статуса: а можем ли мы вообще завершать проект?

```
class Web::Projects::FinishesController < Web::Projects::ApplicationController
  before_action :check_availability

  def new
  end

  def create
  end

  private
  def check_availability
    redirect_to resource_project unless resource_project.can_finish?
  end
end
```

Аналогично можно поступать с пошаговыми формами: каждый шаг - это отдельный вложенный ресурс.

Идеальный случай, это когда используется только стандартные экшены. Понятно, что бывают исключения, но это случается очень редко.

# Responders

[Gem respongers](https://github.com/plataformatec/responders) помогает убрать повторяюющуюся логику из контроллеров.

* автоматически проставляет flash при редиректах из локалей
* делает код экшенов линейным
* можно вынести общую логику, например, выбор верисии сериалайзера, проставлять заголовки.

```
# я немного отошел от рекомендуемой конфигурации
# responders хранятся в /app/responders

class Web::ApplicationController < ApplicationController
  self.responder = WebResponder # потомок ActionController::Responder
  respond_to :html
end

class Web::UsersController < Web::ApplicationController
  def index
    @users = User.all
    respond_with @users
  end

  def update
    @user = User.find params[:id]
    @user.update user_params
    respond_with @user
  end
end 
```

## Иерархия контроллеров

Подробное описание есть в [статье Кирилла Мокевнина](http://habrahabr.ru/post/136461/). 
Что то подобное я видел в англоязычном блоге, но ссылку не приведу.

Цель этой методики организовать контроллеры. 
Сначала приложени рендерит только html. Потом появляется ajax, те же html, только без layout.
Потом появляется api, и вторая версия api, первую версию оставляем для обратной совместимости. Api использует для аутентификации токен в заголовке, а не cookie.
Потом появляются rss ленты, для гостей и зарегистрированных, причем rss клиенты не умеют работать с cookies. В ссылку на rss feed нужно включать токен пользователя.
После требуется использовать js фреймворк и написать json api для этого с аутентификацией через текущую сесси.




